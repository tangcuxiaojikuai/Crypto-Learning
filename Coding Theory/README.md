既然code-based cryptography作为后量子密码备选方案的一种，那当然有必要至少粗浅的了解一下编码理论，这篇文章和isogeny那篇一样，记录一下自己入门过程的同时也记录一下自己的一些理解。

<!--more-->

### 数字通信基本流程

数字通信可以看作是发信方和收信方的信息传递，其三个基本组成要素为：

+ **信源**：消息的来源，也就是发信方
+ **信道**：消息的传输媒介
+ **信宿**：消息的归宿，也就是收信方

因此，数字通信的大体工作框架可以由这三个要素如下表示：

![image-20241008111552387](image-20241008111552387.png)

而实际的数字通信中，为了其能够更好的工作，我们通常需要考虑以下几个问题：

+ **效率**：我们要争取用最少的资源发送信息，也就是避免不必要的冗余
+ **噪声**：实际的通信信道都是非理想的，难免会引入噪声，导致我们想要传递的内容有较低但不可忽略的概率受到影响，出现一些误差，我们需要处理这些误差来获得原信息

因此一个更详细的数字通信过程可以表示为：（在这里我们不考虑信号的物理层面，比如调制/解调之类）：

![image-20241008113325298](image-20241008113325298.png)

可以看出多了两个编码解码器，但这两个编码解码器的功能有很大不同：

+ **信源编码器**：压缩信息，用更少的比特来承载原信息，从而减少冗余，减少在信道上占用容量。比如用Huffman编码
+ **信道编码器**：利用各种差错控制码，对传输的内容进行差错控制保护，从而使得传输内容即使受到一定噪声影响后，通过信道解码器依然能还原出准确无误的信息

而后者是这篇文章讨论的重点，也就是差错控制码究竟通过什么手段实现的解码。

<br/>

<br/>

### 差错控制编码

#### 差错控制方式

对于信道来说，其处理错误一般可以有以下几种方式：

+ **仅检错**：利用差错控制码，接收方在一定范围内，可以判断收到的内容是否出现了错误，如果出现错误可以要求重发，直至无误

+ **仅纠错**：利用差错控制码，接收方在一定范围内，可以判断收到的内容是否出现了错误并纠正错误

  > 很容易理解这种方式在同样的错误下，对于差错控制码的性能要求更高，反过来说也就是编码解码的成本肯定会提高，效率就会降低。因此通常用在实时性比较强的场景

+ **纠错+检错**：利用差错控制码，接收方在检测到出现较少错误时，直接纠错得到正确内容；在检测到出现较多错误时，纠错能力无法满足要求，此时要求发送方重发

<br/>

#### 基本思想

我们不妨把待传输信息的内容先局限于二进制串（事实其实也是如此），记为m，假设他长为k，显然他可以写作一个01向量：
$$
\textbf{m} = (m_1,m_2,...m_k) \quad , \quad m_i \in \{0,1\}
$$
而差错控制码的基本思想是**增加冗余**，也就是在k个信息位的基础上，增加一些与这些信息位有一定关联的冗余位（称作校验位或者监督位），并附加在这些信息位中，得到最后的待传输信息，也就是码字。

比如对于上面长为k的信息位m，我们用某种约束生成n-k个冗余位，并写成向量c：
$$
\textbf{c} = (c_1, c_2, ...,c_{n-k}) \quad , \quad c_i \in \{0,1\}
$$
那么就简单的把这些冗余位附加在信息位后面，就得到了码字w，他同样也是一个向量：
$$
\textbf{w} = (m_1,m_2,...m_k,c_1, c_2, ...,c_{n-k}) = (w_1,w_2,...,w_n) \quad , \quad w_i \in \{0,1\})
$$
此时我们有以下概念：

+ **编码效率**：$\frac{k}{n}$，也就是信息位长度占码字长度的比率
+ **冗余位**：$\frac{n-k}{n}$，也就是冗余位长度占码字长度的比率

可以看出，对于编码方法来说，他们的几个核心要素是：

+ 冗余位的数量
+ 冗余位与信息位的特定关联关系
+ 冗余位的附加方式

<br/>

#### 分类

对于差错控制编码，通常可以有以下几个分类方法：

##### 按照关联关系分类

+ **线性码**：冗余位与信息位的关系是线性的

+ **非线性码**：冗余位与信息位的关系是非线性的

##### 按照影响分组分类

+ **分组码**：冗余位和信息位以码组为单位建立关系，且不同分组之间不会相互影响
+ **卷积码**：冗余位和信息位以码组为单位建立关系，但当前分组冗余位不仅与本组的信息位有关，还与前面码组的信息位有关

> 这里出现了一个新的名词码组，其与码字的关系为若干个码组构成一个码字，下面是一个示例码字w：
> $$
> w = (m_{1,1},...m_{1,k},c_{1,1}, ...,c_{1,n-k},m_{2,1},...m_{2,k},c_{2,1}, ...,c_{2,n-k},m_{3,1},...)
> $$
> 其中一组m、c就是一个码组，一个码组构成一个码字自然也叫分组码。

##### 按照编码前后信息码排列结构是否变化分类

+ **系统码**：编码前后不改变信息位的排列结构
+ **非系统码**：编码前后改变信息位的排列结构，此时无法看出通过码字看出原信息位

<br/>

<br/>

### 线性分组码

如果冗余位与信息位的关系是线性的且为分组码，这种编码就是线性分组码。

#### 基本概念

##### 许用码字集合及禁用码字集合

对于信息位长k，冗余位长n-k的(n,k)-码字来说，其应该具有如下性质：

+ 对于所有$2^k$个信息位，都该对应一个独特的码字，这些码字也就构成了一个大小为$2^k$的集合，即许用码字集合
+ 码字长为n，其对应n维空间中共有$2^n$个向量，其中有$2^k$个向量为许用码字，而剩余向量都不是合法码字，他们也构成一个集合，即禁用码字集合

如果接收到的向量在禁用码字中，则说明受到了噪声影响，此时就需要差错控制编码进行差错控制。

##### 码距

对于01组成的两个码字向量w1、w2，其码距定义为**w1和w2之间的汉明距离**，记为$D(w_1,w_2)$。其具有基本性质如下：

+ **自反性**：$D(w_1,w_1) = 0$

+ **对称性**：$D(w_1,w_2) = D(w_2,w_1)$

+ **三角不等式性**：$D(w_1,w_2) + D(w_2,w_3) \ge D(w_1,w_3)$

  > 最后这个性质似乎不是那么显然，一个比较好理解的思路是：w1到w2会有$D(w_1,w_2)$个比特发生翻转，w2到w3会有$D(w_2,w_3)$个比特发生翻转，当且仅当两部分翻转比特没有重合部分时等号成立，否则代表着有一部分比特在w1到w3时等价于没有翻转，此时不等号成立

##### 最小距离

对于(n,k)-线性分组码，其最小距离定义为：
$$
d_{min} = min \; D(w_i,w_j) \quad , \quad i \neq j
$$
即许用码字集合中，任意两个不相同码字间码距的最小值。

##### 最小距离与纠错检错能力的关系

+ 若线性分组码能检测出任意码字中小于等于e位的误码，则：
  $$
  d_{min} \ge e+1
  $$

  > 因为如果$e \ge d_{min}$，那么许用码字经e位误差之后可能到达另一个许用码字，无法检测出错误

+ 若线性分组码能检测并纠正任意码字中小于等于e位的误码，则：
  $$
  d_{min} \ge 2e+1
  $$

  > 否则可能会误判为另一个许用码字产生的误码

<br/>

#### 生成矩阵

对于(n，k)码来说，其n-k个冗余位都是关于k个信息位的表达式，也就是：
$$
c_1 = f_1(m_1,m_2,...,m_k)
$$

$$
c_2 = f_2(m_1,m_2,...,m_k)
$$

$$
...
$$

$$
c_{n-k} = f_{n-k}(m_1,m_2,...,m_k)
$$

而当上述f都是线性函数时，得到的就是编码就是线性码。

再其实细想一下会发现，信息位自己本身也是自己的线性关系，也就是恒等关系，所以整个信息位的编码过程其实是个矩阵方程：
$$
(m_1,m_2,...,m_k)
\left(\begin{matrix}
1&&&&f_{1,1}&\cdots&f_{1,k}\\
&1&&&f_{2,1}&\cdots&f_{2,k}\\
&&\ddots&&\vdots&\ddots&\vdots\\
&&&1&f_{n-k,1}&\cdots&f_{n-k,k}\\
\end{matrix}\right)
=
(m_1,m_2,...,m_k,c_1,c_2,...,c_{n-k})
=\textbf{w}
$$
我们记：
$$
G =
\left(\begin{matrix}
1&&&&f_{1,1}&\cdots&f_{1,k}\\
&1&&&f_{2,1}&\cdots&f_{2,k}\\
&&\ddots&&\vdots&\ddots&\vdots\\
&&&1&f_{n-k,1}&\cdots&f_{n-k,k}\\
\end{matrix}\right)
$$
G就是这个(n，k)-线性码的生成矩阵，可以发现他可以分块成：
$$
G =
\left(\begin{matrix}
I_k & P_{k,n-k}
\end{matrix}\right)
$$
其中P为冗余位的线性关系构成的矩阵。

> 此时的编码显然也是一个系统码，因为信息位部分是恒等关系直接映射到码字，没有打乱信息位的排列结构
>
> 把冗余位附加在信息位之后是常用的做法，当然附加在前面也行

<br/>

#### 校验矩阵

回顾一下生成矩阵，我们很容易发现其分块成的两个矩阵分别对应信息位和监督位，其分别对应两类方程：

信息位：
$$
w_1 = m_1,w_2 = m_2,...,w_k = m_k
$$
校验位：
$$
w_{k+1} = f_{1,1}m_1 + f_{2,1}m_2 + ...f_{n-k,1}m_k
$$

$$
...
$$

$$
w_{n} = f_{1,k}m_1 + f_{2,k}m_2 + ...f_{n-k,k}m_k
$$

把第一部分的方程代入第二部分，我们能够得到仅由码字向量组成的方程组：
$$
w_{k+1} = f_{1,1}w_1 + f_{2,1}w_2 + ...f_{n-k,1}w_k
$$

$$
...
$$

$$
w_{n} = f_{1,k}w_1 + f_{2,k}w_2 + ...f_{n-k,k}w_k
$$

移项之后会得到一个齐次方程组：
$$
f_{1,1}w_1 + f_{2,1}w_2 + ...f_{n-k,1}w_k + w_{k+1} = 0
$$

$$
...
$$

$$
f_{1,k}w_1 + f_{2,k}w_2 + ...f_{n-k,k}w_k + w_{n} = 0
$$

这个齐次方程组就可以提取作一个矩阵方程：
$$
\left(\begin{matrix}
f_{1,1}&f_{2,1}&\cdots&f_{n-k,1}&1&&&\\
f_{1,2}&f_{2,2}&\cdots&f_{n-k,2}&&1&&\\
\vdots&\vdots&\ddots&\vdots&&&\ddots&\\
f_{1,k}&f_{2,k}&\cdots&f_{n-k,k}&&&&1\\
\end{matrix}\right)
\left(\begin{matrix}
w_1\\
w_2\\
\vdots\\
w_k\\
w_{k+1}\\
\vdots\\
w_n\\
\end{matrix}\right)
=
\left(\begin{matrix}
0\\
0\\
\vdots\\
0\\
\end{matrix}\right)
$$
记：
$$
H =
\left(\begin{matrix}
f_{1,1}&f_{2,1}&\cdots&f_{n-k,1}&1&&&\\
f_{1,2}&f_{2,2}&\cdots&f_{n-k,2}&&1&&\\
\vdots&\vdots&\ddots&\vdots&&&\ddots&\\
f_{1,k}&f_{2,k}&\cdots&f_{n-k,k}&&&&1\\
\end{matrix}\right)
$$
H就是这个(n，k)-线性码的校验矩阵，可以发现他也可以分块成：
$$
H =
\left(\begin{matrix}
P^T_{n-k,k}&I_{n-k}
\end{matrix}\right)
$$
可以发现，对于一个正确的码字向量w来说，一定有：
$$
H\textbf{w} = \textbf{0}
$$

> 然而上述方程成立并不能说明码字没有错误，最简单的例子就是error实在太多，超出检错能力，使得当前码字变成了另一个码字，就当然检测不出来
>
> 然而如果上述方程不成立，则一定说明码字出现了错误

<br/>

#### 生成矩阵和校验矩阵的部分性质

1. 生成矩阵行满秩

   > 证明很简单，因为生成矩阵的分块矩阵第一部分为恒等矩阵，显然无法行变换消去分量，所以生成矩阵行向量线性无关，因此生成矩阵秩就等于k。

2. 生成矩阵的每一行都是许用码字

   > 证明也很简单，因为生成矩阵的每一行其实就对应于信息向量分别取下列值时的码字：
   > $$
   > (1,0,...,0)
   > $$
   >
   > $$
   > (0,1,...,0)
   > $$
   >
   > $$
   > ...
   > $$
   >
   > $$
   > (0,0,...,1)
   > $$

3. 所有许用码字均为生成矩阵行向量的线性组合

   > 这性质感觉像凑数的TT，太显然了
   >
   > 这也就是说生成矩阵行向量就是码字空间的一组基

4. 生成矩阵和校验矩阵互为零空间，也就是他们满足下述方程：
   $$
   HG^T = O
   $$

   > 证明思路基于上述第二条性质，因为G每一行都是许用码字，因此其转置之后每一列都是许用码字，由校验矩阵的作用，对每一列就都有：
   > $$
   > H\textbf{g} = \textbf{0}
   > $$
   > 所以等式成立

<br/>

#### 伴随式和校正子



### 具体编码与decode方法

#### GRS

#### Goppa code

#### ISD

